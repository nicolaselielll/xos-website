'use strict';

const path = require('path');
const buildUtils = require('@vercel/build-utils');
const consola = require('consola');
const fs = require('fs-extra');
const resolveFrom = require('resolve-from');
const semver = require('semver');
const rc9 = require('rc9');
const ufo = require('ufo');
const jiti = require('jiti');
const execa = require('execa');
const replaceInFile = require('replace-in-file');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const consola__default = /*#__PURE__*/_interopDefaultLegacy(consola);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
const resolveFrom__default = /*#__PURE__*/_interopDefaultLegacy(resolveFrom);
const jiti__default = /*#__PURE__*/_interopDefaultLegacy(jiti);
const execa__default = /*#__PURE__*/_interopDefaultLegacy(execa);
const replaceInFile__default = /*#__PURE__*/_interopDefaultLegacy(replaceInFile);

function exec(cmd, args, { env, ...opts } = {}) {
  args = args.filter(Boolean);
  consola__default['default'].log("Running", cmd, ...args);
  return execa__default['default']("npx", [cmd, ...args], {
    stdout: process.stdout,
    stderr: process.stderr,
    preferLocal: false,
    env: {
      MINIMAL: "1",
      NODE_OPTIONS: "--max_old_space_size=3000",
      ...env
    },
    ...opts,
    stdio: Array.isArray(opts.stdio) ? opts.stdio.filter(Boolean) : opts.stdio
  });
}
async function readJSON(filename) {
  try {
    return await fs__default['default'].readJSON(filename);
  } catch (e) {
    return await fs__default['default'].readJSON(filename, { encoding: "utf16le" });
  }
}
function validateEntrypoint(entrypoint) {
  const filename = path__default['default'].basename(entrypoint);
  if (["package.json", "nuxt.config.js", "nuxt.config.ts"].includes(filename) === false) {
    throw new Error('Specified "src" for "@nuxtjs/vercel-builder" has to be "package.json", "nuxt.config.js" or "nuxt.config.ts"');
  }
}
function renameFiles(files, renameFn) {
  const newFiles = {};
  for (const fileName in files) {
    newFiles[renameFn(fileName)] = files[fileName];
  }
  return newFiles;
}
async function globAndRename(pattern, opts, renameFn) {
  const files = await buildUtils.glob(pattern, opts);
  return renameFiles(files, renameFn);
}
function globAndPrefix(pattern, opts, prefix) {
  return globAndRename(pattern, opts, (name) => path__default['default'].join(prefix, name));
}
function findNuxtDep(pkg) {
  for (const section of ["dependencies", "devDependencies"]) {
    const deps = pkg[section];
    if (deps) {
      for (const suffix of ["-edge", ""]) {
        const name = "nuxt" + suffix;
        const version = deps[name];
        if (version) {
          const semver = version.replace(/^[\^~><=]{1,2}/, "");
          return {
            name,
            version,
            semver,
            suffix,
            section
          };
        }
      }
    }
  }
}
function preparePkgForProd(pkg) {
  if (!pkg.dependencies) {
    pkg.dependencies = {};
  }
  if (!pkg.devDependencies) {
    pkg.devDependencies = {};
  }
  const nuxtDependency = findNuxtDep(pkg);
  if (!nuxtDependency) {
    throw new Error("No nuxt dependency found in package.json");
  }
  for (const distro of ["nuxt", "nuxt-start"]) {
    for (const suffix of ["-edge", ""]) {
      delete pkg.dependencies[distro + suffix];
    }
  }
  delete pkg.devDependencies;
  pkg.dependencies["@nuxt/core" + nuxtDependency.suffix] = nuxtDependency.version;
  return nuxtDependency;
}
let _step;
let _stepStartTime;
const dash = " ----------------- ";
function hrToMs(hr) {
  const hrTime = process.hrtime(hr);
  return (hrTime[0] * 1e9 + hrTime[1]) / 1e6;
}
function endStep() {
  if (!_step) {
    return;
  }
  if (_step && _stepStartTime) {
    consola__default['default'].info(`${_step} took: ${hrToMs(_stepStartTime)} ms`);
  }
  _step = void 0;
  _stepStartTime = void 0;
}
function startStep(step) {
  endStep();
  consola__default['default'].log(dash + step + dash);
  _step = step;
  _stepStartTime = process.hrtime();
}
function getNuxtConfig(rootDir, nuxtConfigName) {
  const load = jiti__default['default']();
  const nuxtConfigFile = load(path__default['default'].resolve(rootDir, nuxtConfigName));
  return nuxtConfigFile.default || nuxtConfigFile;
}
function getNuxtConfigName(rootDir) {
  for (const filename of ["nuxt.config.ts", "nuxt.config.js"]) {
    if (fs__default['default'].existsSync(path__default['default'].resolve(rootDir, filename))) {
      return filename;
    }
  }
  throw new Error(`Can not read nuxt.config from ${rootDir}`);
}
async function prepareNodeModules(entrypointPath, modulesDir) {
  const modulesPath = path__default['default'].join(entrypointPath, "node_modules");
  try {
    const prodPath = path__default['default'].join(entrypointPath, modulesDir);
    if (fs__default['default'].existsSync(prodPath)) {
      consola__default['default'].log(`Using cached ${modulesDir}`);
    }
    try {
      if (fs__default['default'].existsSync(modulesPath)) {
        await fs__default['default'].unlink(modulesPath);
      }
      await fs__default['default'].mkdirp(modulesDir);
    } catch (e) {
      if (fs__default['default'].existsSync(prodPath)) {
        fs__default['default'].rmdirSync(modulesPath, { recursive: true });
      } else {
        fs__default['default'].moveSync(modulesPath, prodPath);
      }
    }
    await fs__default['default'].symlink(modulesDir, modulesPath);
  } catch (e) {
    consola__default['default'].log(`Error linking/unlinking ${modulesDir}.`, e);
  }
}

async function prepareTypescriptEnvironment({ pkg, spawnOpts, rootDir }) {
  spawnOpts = { ...spawnOpts, env: { ...spawnOpts.env, NODE_PRESERVE_SYMLINKS: "1" } };
  if (fs__default['default'].existsSync("tsconfig.json")) {
    let tsConfig;
    try {
      tsConfig = await readJSON("tsconfig.json");
    } catch (e) {
      throw new Error(`Can not read tsconfig.json from ${rootDir}`);
    }
    tsConfig.exclude = [...tsConfig.exclude || [], "node_modules_dev", "node_modules_prod"];
    await fs__default['default'].writeJSON("tsconfig.json", tsConfig);
  }
  if (pkg.dependencies && Object.keys(pkg.dependencies).includes("@nuxt/typescript-runtime")) {
    delete pkg.dependencies["@nuxt/typescript-runtime"];
  }
}
async function readAndMergeOptions(filename, rootDir, options) {
  let newOptions = options;
  if (fs__default['default'].existsSync(filename)) {
    let tsConfig;
    try {
      tsConfig = await readJSON(filename);
    } catch (e) {
      throw new Error(`Can not read ${filename} from ${rootDir}`);
    }
    newOptions = { ...tsConfig.compilerOptions, ...options };
  }
  return newOptions;
}
async function getTypescriptCompilerOptions(rootDir, options = {}) {
  let compilerOptions = [];
  const sources = [
    "tsconfig.json",
    "tsconfig.vercel.json",
    "tsconfig.now.json"
  ];
  for (const source of sources) {
    options = await readAndMergeOptions(source, rootDir, options);
  }
  compilerOptions = Object.keys(options).reduce((compilerOptions2, option) => {
    if (compilerOptions2 && !["rootDirs", "paths", "outDir", "rootDir", "noEmit"].includes(option)) {
      compilerOptions2.push(`--${option}`, String(options[option]));
    }
    return compilerOptions2;
  }, []);
  return [...compilerOptions, "--noEmit", "false", "--rootDir", rootDir, "--outDir", "now_compiled"];
}
async function compileTypescriptBuildFiles({ rootDir, spawnOpts, tscOptions }) {
  const nuxtConfigName = getNuxtConfigName(rootDir);
  const compilerOptions = await getTypescriptCompilerOptions(rootDir, tscOptions);
  await fs__default['default'].mkdirp("now_compiled");
  await exec("tsc", [...compilerOptions, nuxtConfigName], spawnOpts);
  const nuxtConfigFile = getNuxtConfig(rootDir, "now_compiled/nuxt.config.js");
  const { serverMiddleware, modules } = nuxtConfigFile;
  const filesToCompile = [
    ...serverMiddleware || [],
    ...modules || []
  ].reduce((filesToCompile2, item) => {
    let itemPath = "";
    if (typeof item === "string") {
      itemPath = item;
    } else if (typeof item === "object" && Array.isArray(item)) {
      if (typeof item[0] === "string") {
        itemPath = item[0];
      }
    } else if (typeof item === "object" && typeof item.handler === "string") {
      itemPath = item.handler;
    }
    if (itemPath) {
      const srcDir = nuxtConfigFile.srcDir ? path__default['default'].relative(rootDir, nuxtConfigFile.srcDir).replace("now_compiled", ".") : ".";
      const resolvedPath = path__default['default'].resolve(rootDir, itemPath.replace(/^[@~]\//, `${srcDir}/`).replace(/\.ts$/, ""));
      if (fs__default['default'].existsSync(`${resolvedPath}.ts`)) {
        filesToCompile2.push(resolvedPath);
        replaceInFile__default['default'].sync({
          files: path__default['default'].resolve(rootDir, "now_compiled/nuxt.config.js"),
          from: new RegExp(`(?<=['"\`])${itemPath}(?=['"\`])`, "g"),
          to: itemPath.replace(/\.ts$/, "")
        });
      }
    }
    return filesToCompile2;
  }, []);
  await Promise.all(filesToCompile.map((file) => exec("tsc", [...compilerOptions, file])));
  const files = await buildUtils.glob("**", path__default['default'].join(rootDir, "now_compiled"));
  Object.keys(files).forEach((filename) => {
    const compiledPath = files[filename].fsPath;
    const newPath = compiledPath.replace("/now_compiled/", "/");
    fs__default['default'].moveSync(compiledPath, newPath, { overwrite: true });
    files[filename].fsPath = newPath;
  });
  return files;
}

async function build(opts) {
  const { files, entrypoint, workPath, config = {}, meta = {} } = opts;
  consola__default['default'].log("Running with @nuxt/vercel-builder version", require("../package.json").version);
  startStep("Prepare build");
  validateEntrypoint(entrypoint);
  const entrypointDirname = path__default['default'].dirname(entrypoint);
  const entrypointPath = path__default['default'].join(workPath, entrypointDirname);
  const modulesPath = path__default['default'].join(entrypointPath, "node_modules");
  consola__default['default'].log("Downloading files...");
  await buildUtils.download(files, workPath, meta);
  process.chdir(entrypointPath);
  consola__default['default'].log("Working directory:", process.cwd());
  let pkg;
  try {
    pkg = await readJSON("package.json");
  } catch (e) {
    throw new Error(`Can not read package.json from ${entrypointPath}`);
  }
  const nodeVersion = await buildUtils.getNodeVersion(entrypointPath, void 0, {}, meta);
  const spawnOpts = buildUtils.getSpawnOptions(meta, nodeVersion);
  const usesTypescript = pkg.devDependencies && Object.keys(pkg.devDependencies).includes("@nuxt/typescript-build") || pkg.dependencies && Object.keys(pkg.dependencies).includes("@nuxt/typescript");
  const needsTypescriptBuild = getNuxtConfigName(entrypointPath) === "nuxt.config.ts";
  if (usesTypescript) {
    await prepareTypescriptEnvironment({
      pkg,
      spawnOpts,
      rootDir: entrypointPath
    });
  }
  const isYarn = !fs__default['default'].existsSync("package-lock.json");
  consola__default['default'].log("Using", isYarn ? "yarn" : "npm");
  if (process.env.NPM_RC) {
    consola__default['default'].log("Found NPM_RC in environment; creating .npmrc");
    await fs__default['default'].writeFile(".npmrc", process.env.NPM_RC);
  } else if (process.env.NPM_AUTH_TOKEN || process.env.NPM_TOKEN) {
    consola__default['default'].log("Found NPM_AUTH_TOKEN or NPM_TOKEN in environment; creating .npmrc");
    await fs__default['default'].writeFile(".npmrc", `//registry.npmjs.org/:_authToken=${process.env.NPM_AUTH_TOKEN || process.env.NPM_TOKEN}`);
  }
  if (isYarn && !fs__default['default'].existsSync("../.yarnclean")) {
    await fs__default['default'].copyFile(path__default['default'].join(__dirname, "../.yarnclean"), ".yarnclean");
  }
  const cachePath = path__default['default'].resolve(entrypointPath, ".vercel_cache");
  await fs__default['default'].mkdirp(cachePath);
  const yarnCachePath = path__default['default'].join(cachePath, "yarn");
  await fs__default['default'].mkdirp(yarnCachePath);
  if (process.env.VERCEL_ANALYTICS_ID) {
    consola__default['default'].log("Vercel Analytics Detected. Adding @nuxtjs/web-vitals to .nuxtrc");
    rc9.update({ "buildModules[]": require.resolve("@nuxtjs/web-vitals") }, { dir: entrypointPath, name: ".nuxtrc" });
  }
  startStep("Install devDependencies");
  await prepareNodeModules(entrypointPath, "node_modules_dev");
  await buildUtils.runNpmInstall(entrypointPath, [
    "--prefer-offline",
    "--frozen-lockfile",
    "--non-interactive",
    "--production=false",
    `--modules-folder=${modulesPath}`,
    `--cache-folder=${yarnCachePath}`
  ], { ...spawnOpts, env: { ...spawnOpts.env, NODE_ENV: "development" } }, meta);
  const buildSteps = ["vercel-build", "now-build"];
  for (const step of buildSteps) {
    if (pkg.scripts && Object.keys(pkg.scripts).includes(step)) {
      startStep(`Pre build (${step})`);
      await buildUtils.runPackageJsonScript(entrypointPath, step, spawnOpts);
      break;
    }
  }
  startStep("Nuxt build");
  let compiledTypescriptFiles = {};
  if (needsTypescriptBuild) {
    const { tscOptions } = config;
    compiledTypescriptFiles = await compileTypescriptBuildFiles({ rootDir: entrypointPath, spawnOpts, tscOptions });
  }
  const nuxtConfigName = "nuxt.config.js";
  const nuxtConfigFile = getNuxtConfig(entrypointPath, nuxtConfigName);
  const staticDir = nuxtConfigFile.dir && nuxtConfigFile.dir.static ? nuxtConfigFile.dir.static : "static";
  let publicPath = (nuxtConfigFile.build && nuxtConfigFile.build.publicPath ? nuxtConfigFile.build.publicPath : "/_nuxt/").replace(/^\//, "");
  if (ufo.hasProtocol(publicPath)) {
    publicPath = "_nuxt/";
  }
  const buildDir = nuxtConfigFile.buildDir ? path__default['default'].relative(entrypointPath, nuxtConfigFile.buildDir) : ".nuxt";
  const srcDir = nuxtConfigFile.srcDir ? path__default['default'].relative(entrypointPath, nuxtConfigFile.srcDir) : ".";
  const lambdaName = nuxtConfigFile.lambdaName ? nuxtConfigFile.lambdaName : "index";
  const usesServerMiddleware = config.internalServer !== void 0 ? config.internalServer : !!nuxtConfigFile.serverMiddleware;
  await exec("nuxt", [
    "build",
    "--standalone",
    "--no-lock",
    `--config-file "${nuxtConfigName}"`,
    entrypointPath
  ], spawnOpts);
  if (config.generateStaticRoutes) {
    await exec("nuxt", [
      "generate",
      "--no-build",
      "--no-lock",
      `--config-file "${nuxtConfigName}"`,
      entrypointPath
    ], spawnOpts);
  }
  startStep("Install dependencies");
  await prepareNodeModules(entrypointPath, "node_modules_prod");
  const nuxtDep = preparePkgForProd(pkg);
  await fs__default['default'].writeJSON("package.json", pkg);
  await buildUtils.runNpmInstall(entrypointPath, [
    "--prefer-offline",
    "--pure-lockfile",
    "--non-interactive",
    "--production=true",
    `--modules-folder=${modulesPath}`,
    `--cache-folder=${yarnCachePath}`
  ], {
    ...spawnOpts,
    env: {
      ...spawnOpts.env,
      NPM_ONLY_PRODUCTION: "true"
    }
  }, meta);
  const nuxtPkg = require(resolveFrom__default['default'](entrypointPath, `@nuxt/core${nuxtDep.suffix}/package.json`));
  if (!semver.gte(nuxtPkg.version, "2.4.0")) {
    throw new Error(`nuxt >= 2.4.0 is required, detected version ${nuxtPkg.version}`);
  }
  if (semver.gt(nuxtPkg.version, "3.0.0")) {
    consola__default['default'].warn("WARNING: nuxt >= 3.0.0 is not tested against this builder!");
  }
  if (process.env.NPM_AUTH_TOKEN) {
    await fs__default['default'].unlink(".npmrc");
  }
  startStep("Collect artifacts");
  const staticFiles = await buildUtils.glob("**", path__default['default'].join(entrypointPath, srcDir, staticDir));
  const clientDistDir = path__default['default'].join(entrypointPath, buildDir, "dist/client");
  const clientDistFiles = await globAndPrefix("**", clientDistDir, publicPath);
  const serverDistDir = path__default['default'].join(entrypointPath, buildDir, "dist/server");
  const serverDistFiles = await globAndPrefix("**", serverDistDir, path__default['default'].join(buildDir, "dist/server"));
  const generatedDir = path__default['default'].join(entrypointPath, "dist");
  const generatedPagesFiles = config.generateStaticRoutes ? await globAndPrefix("**/*.*", generatedDir, "./") : {};
  const nodeModulesDir = path__default['default'].join(entrypointPath, "node_modules_prod");
  const nodeModules = await globAndPrefix("**", nodeModulesDir, "node_modules");
  const lambdas = {};
  const launcherPath = path__default['default'].join(__dirname, "launcher.js");
  const launcherSrc = (await fs__default['default'].readFile(launcherPath, "utf8")).replace(/__NUXT_SUFFIX__/g, nuxtDep.suffix).replace(/__NUXT_CONFIG__/g, "./" + nuxtConfigName).replace(/\/\* __ENABLE_INTERNAL_SERVER__ \*\/ *true/g, String(usesServerMiddleware));
  const launcherFiles = {
    "vercel__launcher.js": new buildUtils.FileBlob({ data: launcherSrc }),
    "vercel__bridge.js": new buildUtils.FileFsRef({ fsPath: require("@vercel/node-bridge") }),
    [nuxtConfigName]: new buildUtils.FileFsRef({ fsPath: path__default['default'].resolve(entrypointPath, nuxtConfigName) }),
    ...serverDistFiles,
    ...compiledTypescriptFiles,
    ...nodeModules
  };
  const serverFiles = [
    ...Array.isArray(config.includeFiles) ? config.includeFiles : config.includeFiles ? [config.includeFiles] : [],
    ...Array.isArray(config.serverFiles) ? config.serverFiles : [],
    "package.json"
  ];
  for (const pattern of serverFiles) {
    const files2 = await buildUtils.glob(pattern, entrypointPath);
    Object.assign(launcherFiles, files2);
  }
  lambdas[lambdaName] = await buildUtils.createLambda({
    handler: "vercel__launcher.launcher",
    runtime: nodeVersion.runtime,
    files: launcherFiles,
    environment: {
      NODE_ENV: "production"
    },
    maxDuration: config.maxDuration,
    memory: config.memory
  });
  endStep();
  return {
    output: {
      ...lambdas,
      ...clientDistFiles,
      ...staticFiles,
      ...generatedPagesFiles
    },
    routes: [
      { src: `/${publicPath}.+`, headers: { "Cache-Control": "max-age=31557600" } },
      ...Object.keys(staticFiles).map((file) => ({ src: `/${file}`, headers: { "Cache-Control": "max-age=31557600" } })),
      { handle: "filesystem" },
      { src: "/(.*)", dest: "/index" }
    ]
  };
}

const config = {
  maxLambdaSize: "50mb"
};

async function prepareCache({ workPath }) {
  startStep("Collect cache");
  const dirs = process.env.NUXT_CACHE_DISABLED === "1" ? [] : [".nuxt", ".vercel_cache", "node_modules_dev", "node_modules_prod"];
  const cache = {};
  for (const dir of dirs) {
    const files = await buildUtils.glob(`**/${dir}/**`, workPath);
    consola__default['default'].info(`${Object.keys(files).length} files collected from ${dir}`);
    Object.assign(cache, files);
  }
  endStep();
  return cache;
}

module.exports = {
  version: 2,
  build,
  config,
  prepareCache
};
